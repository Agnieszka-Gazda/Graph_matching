import networkx as nx
import random
import math
import operator
import copy


def check_if_ismorphic(G1, G2):
    '''
    TO CHECK, ASK HOW TO COMPARE, SUM??
    First stage of algorithm, compare the parameters of two graphs in order to chceck if are isomorphic
    '''
    para1 = count_parameters(G1)
    para2 = count_parameters(G2)
    if len(para1) != len(para2):
        # different number of nodes
        return False
    else:
        for i, node in enumerate(para1):
            if node[1] != para2[i][1] or node[2] != para2[i][2] or node[3] != para2[i][3]:
                return False
    return True

def count_parameters(G):
    '''
            :param G: graph
            :param graph_parameters:
            :return: mmatrix with parameters to count fittness function
            [node, degree, sum of shortest paths, eccentrity (max shortest path)]
            '''
    graph_parameters = []
    N = nx.number_of_nodes(G)
    # print(N)
    nodes = nx.nodes(G)
    for i in nodes:
        deg = nx.degree(G, i)
        # if Sp=0, then the SP doesn't exist
        SP = nx.single_source_shortest_path_length(G, i)
        sum_SP = 0
        Ecc = 0
        for j in SP:
            if SP[j] > Ecc:
                Ecc = SP[j]
            sum_SP = sum_SP + SP[j]
        param = [i, deg, sum_SP, Ecc]
        graph_parameters.append(param)

    return graph_parameters

class GA:

    def __init__(self, G1, G2, r0=0.01, iter=1500):
        self.G1 = G1
        self.G2 = G2
        self.ro = r0
        self.para1 = count_parameters(G1)
        self.para2=count_parameters(G2)
        self.iter=iter
        self.Init=250


    def create_initial_population(self):

        # print(Init)
        populationCR = []
        for i in range(1, int(self.Init)):
            populationCR.append(self.create_chromosome_random())

        populationCR_fitness = []
        for chromosome in populationCR:
            fitness = self.fitness_function(chromosome)
            temp = dict()
            temp['chromosome'] = chromosome
            temp['fitness'] = fitness
            populationCR_fitness.append(temp)
        # print(populationCR_fitness)

        return populationCR_fitness

    def create_chromosome_random(self):
        '''
        gen = (v1, d1, e1,)
        one chromosome is one whole fit
        '''
        print("CREATE CHROMOSOME")
        para2=copy.deepcopy(self.para2)
        para1=copy.deepcopy(self.para1)
        random.shuffle(para2)
        # print(para2)
        chromosome = []
        for i, node in enumerate(para1):
            gen = node + para2[i]
            chromosome.append(gen)

        print(chromosome)
        return chromosome

    def fitness_function(self, chromosome):
        sum = 0
        for gen in chromosome:
            inv = abs(gen[1] * gen[2] * gen[3] - gen[5] * gen[6] * gen[7])
            sum = sum + inv
        fitness = 1 / (sum + self.ro)
        # print('FITNESS: {}, {}, {}'.format(chromosome, fitness, ro))
        return fitness

    def pick_parents_ranking_list(self, population):
        population.sort(key=operator.itemgetter('fitness'))
        # print('sorted: {}'.format(population))
        parents = []
        parents.append(population[-1])
        parents.append(population[-2])
        return parents

    def crossover(self, parents):
        print('input')
        parent0 = parents[0]['chromosome']
        parent1 = parents[1]['chromosome']
        print(parent0)
        print(parent1)

        n = len(parents[0]['chromosome'])
        CP1 = random.randint(0, n - 1)
        CP2 = random.randint(0, n - 1)
        print(CP1, CP2)

        temp = copy.deepcopy(parent1[CP2])
        temp2 = copy.deepcopy(parent0[CP1])
        # print(temp2)
        # print(temp)
        in_first = parents[0]['chromosome'][CP1]
        in_second = parents[1]['chromosome'][CP2]
        ## dont know if can do that

        for i in parents[0]['chromosome']:
            changed_in_first = in_second[0]
            if i[0] == changed_in_first:
                i[0:4] = in_first[0:4]
            if i[4] == in_second[4]:
                i[4:8] = in_first[4:8]

        for i in parents[1]['chromosome']:
            changed_in_second = in_first[0]
            if i[0] == changed_in_second:
                i[0:4] = in_second[0:4]
            if i[4] == in_first[4]:
                i[4:8] = in_second[4:8]

        parents[0]['chromosome'][CP1] = temp
        parents[1]['chromosome'][CP2] = temp2

        parents[0]['fitness'] = self.fitness_function(parents[0]['chromosome'])
        parents[1]['fitness'] = self.fitness_function(parents[1]['chromosome'])
        print('output')
        print(parents[0])
        print(parents[1])
        return parents

    def mutation(self, parents):
        n = len(parents[0]['chromosome'])
        # print('Mutation')
        CP1 = random.randint(0, n - 1)
        CP2 = random.randint(0, n - 1)
        print(CP1, CP2)

        # first child
        # print(parents[0])
        temp = copy.deepcopy(parents[0]['chromosome'][CP1])
        # print(temp)
        parents[0]['chromosome'][CP1][0:4] = parents[0]['chromosome'][CP2][0:4]
        # print(parents[0]['chromosome'][CP2])
        parents[0]['chromosome'][CP2][0:4] = temp[0:4]
        # print(parents[0])

        parents[0]['fitness'] = self.fitness_function(parents[0]['chromosome'])
        parents[1]['fitness'] = self.fitness_function(parents[1]['chromosome'])

        return parents

    def Generic_algorithm(self):
        n = nx.number_of_nodes(self.G1)

        if n <= 5:
            Init = math.factorial(n) / 5
        elif n > 5 and n <= 7:
            Init = math.factorial(n) / 20
        self.Init=copy.deepcopy(Init)

        population = self.create_initial_population()
        parents = self.pick_parents_ranking_list(population)

        for i in range(0, self.iter):
            parents = self.pick_parents_ranking_list(population)
            M = parents[0]['fitness']
            if (M == 100):
                print("Found in {} iteration".format(i))
                print(parents[0])
                break

            cross_child = self.crossover(parents)
            muted_child = self.mutation(cross_child)
            # print(muted_child[0]['fitness'])
            # print(muted_child[1]['fitness'])
            population.sort(key=operator.itemgetter('fitness'))
            if (population[0]['fitness']) < muted_child[0]['fitness']:
                population[0] = muted_child[0]
            if (population[1]['fitness']) < muted_child[0]['fitness']:
                population[1] = muted_child[0]
            if (population[0]['fitness']) < muted_child[1]['fitness']:
                population[0] = muted_child[1]
            if (population[1]['fitness']) < muted_child[1]['fitness']:
                population[1] = muted_child[1]
            print(M)



G = nx.Graph()
G.add_nodes_from([1, 2, 3, 4, 5, 6, 7])
G.add_edges_from([(1, 2), (1, 3), (1, 4), (4, 3), (4, 2), (2, 5), (4, 5), (1, 6), (7, 6)])

G2 = nx.Graph()
G2.add_nodes_from([1, 2, 3, 4, 5, 6, 7])
G2.add_edges_from([(1, 2), (1, 3), (1, 4), (4, 3), (4, 2), (2, 5), (4, 5), (1, 6), (7, 6)])
GA=GA(G, G2)
GA.Generic_algorithm()
