import networkx as nx
import random
import math
import operator

def count_parameters(G):
    '''
    :param G: graph
    :param graph_parameters:
    :return: mmatrix with parameters to count fittness function
    [node, degree, sum of shortest paths, eccentrity (max shortest path)]
    '''
    graph_parameters = []
    N = nx.number_of_nodes(G)
    #print(N)
    nodes = nx.nodes(G)
    for i in nodes:
        deg = nx.degree(G,i)
        # if Sp=0, then the SP doesn't exist
        SP = nx.single_source_shortest_path_length(G, i)
        sum_SP = 0
        Ecc = 0
        for j in SP:
            if SP[j] > Ecc:
                Ecc = SP[j]
            sum_SP = sum_SP + SP[j]
        param = [i, deg, sum_SP, Ecc]
        graph_parameters.append(param)

    return graph_parameters


def check_if_ismorphic(G1, G2):
    '''
    TO CHECK, ASK HOW TO COMPARE, SUM??
    First stage of algorithm, compare the parameters of two graphs in order to chceck if are isomorphic
    '''
    para1 = count_parameters(G1)
    para2 = count_parameters(G2)
    if len(para1)!= len(para2):
        # different number of nodes
        return False
    else:
        for i, node in enumerate(para1):
            if node[1] !=para2[i][1] or node[2] !=para2[i][2] or node[3] !=para2[i][3]:
                return False
    return True

def create_chromosome_random(para1, para2):
    '''
    gen = (v1, d1, e1,)
    one chromosome is one whole fit
    '''
    #print(para1)
    #print(para2)
    random.shuffle(para2)
    #print(para2)
    chromosome = []
    for i, node in enumerate(para1):
        gen = node + para2[i]
        chromosome.append(gen)
    #print(chromosome)
    return chromosome

def fitness_function_demo(para1, para2, G1, G2, ro = 0.01):
    #print(para1)
    sum = 0
    for i, node in enumerate(para1):
        inv = abs(node[1]*node[2]*node[3]-para2[i][1]*para2[i][2]*para2[i][3])
        sum = sum + inv
    fitness = 1/(sum +ro)
    #print(fitness)

def fitness_function(chromosome, ro = 0.01):
    sum = 0
    for gen in chromosome:
        inv = abs(gen[1]*gen[2]*gen[3]-gen[5]*gen[6]*gen[7])
        sum = sum + inv
    fitness = 1/(sum+ro)
    #print('FITNESS: {}, {}, {}'.format(chromosome, fitness, ro))
    return fitness


def create_initial_population(n, G1, G2, para1, para2, Init, ro=0.01):

    #print(Init)
    populationCR = []
    for i in range(1, int(Init)):
        populationCR.append(create_chromosome_random(para1, para2))

    populationCR_fitness = []
    for chromosome in populationCR:
        fitness = fitness_function(chromosome, ro)
        temp = dict()
        temp['chromosome'] = chromosome
        temp['fitness'] = fitness
        populationCR_fitness.append(temp)
    #print(populationCR_fitness)

    return populationCR_fitness

def pick_parents_ranking_list(population):
    population.sort( key = operator.itemgetter('fitness'))
    #print('sorted: {}'.format(population))
    parents = []
    parents.append(population[-1])
    parents.append(population[-2])
    return parents

def crossover(parents, probability = 0.9, ro=0.01):
    '''
    dont know if should do sth inside the genes, couse one to muti fit
    '''
    #print(parents[0])
    #print(parents[1])

    n = len(parents[0]['chromosome'])
    CP1 = random.randint(0, n-1)
    CP2 = random.randint(0, n-1)
    #print(CP1, CP2)


    in_first = parents[0]['chromosome'][CP1]
    in_second = parents[1]['chromosome'][CP2]
    ## dont know if can do that

    for i in parents[0]['chromosome']:
        changed_in_first=in_second[0]
        if i[0]==changed_in_first:
            #print('na ten zmieniany{}'.format(i))
            i[0:4]=in_first[0:4]
        if i[4]==in_second[4]:
            #print('na ten zmieniany druga czesc{}'.format(i))
            #print(i[4:8])
            i[4:8] = in_first[4:8]

    for i in parents[1]['chromosome']:
        changed_in_second=in_first[0]
        if i[0]==changed_in_second:
            #print('na ten zmieniany{}'.format(i))
            i[0:4]=in_second[0:4]
        if i[4]==in_first[4]:
            #print('na ten zmieniany druga czesc{}'.format(i))
            #print(i[4:8])
            i[4:8] = in_second[4:8]

    parents[0]['chromosome'][CP1]=parents[1]['chromosome'][CP2]
    parents[1]['chromosome'][CP2]=in_first

    parents[0]['fitness'] = fitness_function(parents[0]['chromosome'], ro)
    parents[1]['fitness'] = fitness_function(parents[1]['chromosome'], ro)

    return parents

def mutation(parents, ro=0.01):
    n = len(parents[0]['chromosome'])
    #print('Mutation')
    CP1 = random.randint(0, n - 1)
    CP2 = random.randint(0, n - 1)
    #print(CP1, CP2)

    #first child
    #print(parents[0])
    temp = parents[0]['chromosome'][CP1]
    #print(temp)
    parents[0]['chromosome'][CP1][0:4]=parents[0]['chromosome'][CP2][0:4]
    #print(parents[0]['chromosome'][CP2])
    parents[0]['chromosome'][CP2][0:4]=temp[0:4]
    #print(parents[0])

    parents[0]['fitness'] = fitness_function(parents[0]['chromosome'], ro)
    parents[1]['fitness'] = fitness_function(parents[1]['chromosome'], ro)

    return parents

def Generic_algorithm(G1, G2, para1, para2, ro=0.01, iter=1500):
    n=nx.number_of_nodes(G1)

    Init = 250
    if n <= 5:
        Init = math.factorial(n) / 5
    elif n > 5 and n <= 7:
        Init = math.factorial(n) / 20

    population = create_initial_population(n,G1, G2, para1, para2, Init)
    parents = pick_parents_ranking_list(population)

    print(parents)
    print(parents[0])

    for i in range(0, iter):
        parents = pick_parents_ranking_list(population)
        M=parents[0]['fitness']
        if(M==100):
            print("ZNALAZLEM W {} iteracji".format(i))
            break

        cross_child = crossover(parents)
        muted_child = mutation(cross_child)
        print(muted_child[0]['fitness'])
        print(muted_child[1]['fitness'])
        population.sort(key=operator.itemgetter('fitness'))
        if(population[0]['fitness'])<muted_child[0]['fitness'] :
            population[0]=muted_child[0]
        if (population[1]['fitness']) < muted_child[0]['fitness']:
            population[1] = muted_child[0]
        if (population[0]['fitness']) < muted_child[1]['fitness']:
            population[0] = muted_child[1]
        if (population[1]['fitness']) < muted_child[1]['fitness']:
            population[1] = muted_child[1]
        print(M)




    print('crossover')
    crossover(parents)
    mutation(parents)

    '''
    K=0
    CRN =[]
    while(K<Init):
        K = K+1
        CRN.append(parents[0])
        CH_cross = crossover(parents)
    '''



G = nx.Graph()
G.add_nodes_from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
G.add_edges_from([(1, 2), (1, 3), (1, 4), (4, 3), (4, 2), (2, 5), (6, 7), (7, 5), (10, 11), (11, 14), (14, 15), (15 ,10), (9, 1)])

G2 = nx.Graph()
G2.add_nodes_from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
G2.add_edges_from([(1, 2), (1, 3), (1, 4), (4, 3), (4, 2), (2, 5), (6, 7), (7, 5), (10, 11), (11, 14), (14, 15), (15 ,10), (9, 1)])


para1 = count_parameters(G)
para2 = count_parameters(G2)
print(check_if_ismorphic(G, G))
Generic_algorithm(G, G2, para1, para2)
